function h(n){return n.includes(":")?6:n.includes(".")?4:0}function a(n){const t=h(n);if(!t)throw new Error(`Invalid IP address: ${n}`);let e=0n;const r={};if(t===4){const i=n.split(".");for(let s=0;s<4;s++)e=e<<8n|BigInt(i[s])}else{if(n.includes(".")&&(r.ipv4mapped=!0,n=n.split(":").map(o=>{if(o.includes(".")){const[c,f,u,l]=o.split(".").map(d=>Number(d).toString(16).padStart(2,"0"));return`${c}${f}:${u}${l}`}else return o}).join(":")),n.includes("%")){let o;[,n,o]=/(.+)%(.+)/.exec(n)||[],r.scopeid=o}const i=n.split(":"),s=i.indexOf("");if(s!==-1)for(;i.length<8;)i.splice(s,0,"");for(const o of i)e=e<<16n|BigInt(parseInt(o||"0",16))}return r.number=e,r.version=t,r}function b({number:n,version:t,ipv4mapped:e,scopeid:r},{compress:i=!0,hexify:s=!1}={}){if(t===4){const o=Number(n);return`${o>>>24&255}.${o>>>16&255}.${o>>>8&255}.${o&255}`}else{const o=new Array(8);let c=n;for(let u=7;u>=0;u--)o[u]=c&0xffffn,c>>=16n;let f="";if(e&&!s){for(const[u,l]of o.entries())u<6?f+=`${l.toString(16)}:`:f+=`${String(l>>8n)}.${String(l&255n)}${u===6?".":""}`;i&&(f=x(f.split(":")))}else i?f=x(o.map(u=>u.toString(16))):f=o.map(u=>u.toString(16)).join(":");return r?`${f}%${r}`:f}}function p(n,{compress:t=!0,hexify:e=!1}={}){return b(a(n),{compress:t,hexify:e})}function x(n){let t=-1,e=0,r=-1,i=0;for(let s=0;s<n.length;s++)n[s]==="0"?r===-1?(r=s,i=1):i++:(i>e&&(t=r,e=i),r=-1,i=0);if(i>e&&(t=r,e=i),e>=2){const s=n.slice(0,t).join(":"),o=n.slice(t+e).join(":");return s&&o?`${s}::${o}`:s?`${s}::`:o?`::${o}`:"::"}return n.join(":")}const v={4:32,6:128};function m(n){return Array.from(new Set(n))}function N(n){return n.includes("/")?h(n):0}function I(n,t){const{number:e,version:r}=a(n.replace(/\/.+/,"")),{number:i,version:s}=a(t.replace(/\/.+/,""));return r===s?e-i>0n?1:e-i<0n?-1:0:r>s?1:0}function $(n){const t=N(n),e=Object.create(null);let r;if(t)r=n,e.version=t;else{const w=h(n);if(w)r=`${n}/${v[w]}`,e.version=w;else throw new Error(`Network is not a CIDR or IP: "${n}"`)}const[i,s]=r.split("/");if(!/^[0-9]+$/.test(s))throw new Error(`Network is not a CIDR or IP: "${n}"`);const{number:o,version:c,ipv4mapped:f,scopeid:u}=a(i);e.ip=b({number:o,version:c,ipv4mapped:f,scopeid:u}),e.cidr=`${e.ip}/${s}`,e.prefix=s,e.prefixPresent=!!t;const l=v[c],d=BigInt(l-Number(s)),y=d>0n?(1n<<d)-1n:0n;return e.start=o&~y,e.end=o|y,e}function S(n,t){return!(t.start<n.start||t.end>n.end)}function P(n){if(n===0n)return 0n;let t=0n,e=n>>1n;for(;e>0n;)t++,e>>=1n;return 1n<<t}function g(n){if(n.end<n.start)return[];if(n.end===n.start)return[n];if(n.end-n.start===1n)return n.end%2n===0n?[{start:n.start,end:n.start},{start:n.end,end:n.end}]:[{start:n.start,end:n.end}];const t=A(n.end,n.start);let e=P(t),r,i;if(t===e&&n.start+t===n.end)return[n];if(n.start%e===0n)r=n.start,i=r+e-1n;else if(r=n.end/e*e,r+e-1n>n.end){for(r=(n.end/e-1n)*e;r<n.start;)e/=2n,r=(n.end/e-1n)*e;i=r+e-1n}else r=n.end/e*e,i=r+e-1n;let s=[{start:r,end:i}];return r!==n.start&&(s=s.concat(g({start:n.start,end:r-1n}))),i!==n.end&&(s=s.concat(g({start:i+1n,end:n.end}))),s}function A(n,t){return n+1n-t}function B(n,t){const e=p(b({number:n.start,version:t})),r=A(n.end,n.start);let i=0,s=r>>1n;for(;s>0n;)s>>=1n,i++;const o=v[t]-i;return`${e}/${o}`}function C(n){const t={4:new Map,6:new Map};for(const{start:e,end:r,version:i}of n){let s=t[i].get(e);s||(s={start:0,end:0},t[i].set(e,s));let o=t[i].get(r);o||(o={start:0,end:0},t[i].set(r,o)),s.start+=1,o.end+=1}return t}function j(n){let t=null,e=null;const r=Array.from(n.keys()).sort((o,c)=>o>c?1:o<c?-1:0);let i=0;const s=[];for(const[o,c]of r.entries()){const f=n.get(c);if(t===null&&f.start&&(t=c),f.end&&(e=c),t===null)continue;f.start&&(i+=f.start),f.end&&(i-=f.end);const u=r[o+1];if(f.end&&i===0&&u!==void 0&&u-c>1n){for(const l of g({start:t,end:e}))s.push(l);t=null,e=null}else if(o===r.length-1)for(const l of g({start:t,end:e}))s.push(l)}return s}function E(n){const t=m(Array.isArray(n)?n:[n]).map($),e=C(t),r={4:[],6:[]};for(const i of[4,6])r[i]=j(e[i]).map(s=>B(s,i));return[...r[4].sort(I),...r[6].sort(I)]}function*k(n){const t=m(Array.isArray(n)?n:[n]);for(const e of E(t)){const{start:r,end:i,version:s}=$(e);for(let o=r;o<=i;o++)yield p(b({number:o,version:s}))}}function V(n,t){const e=m(Array.isArray(n)?n:[n]).map($),r=m(Array.isArray(t)?t:[t]).map($),i=r.length;let s=0;for(const o of e)for(const c of r)if(o.version===c.version&&S(o,c)){s++;continue}return s===i}export{V as c,k as e,E as m,$ as p};
